#!/bin/bash
#################################################################
#								#
# Copyright (c) 2025 YottaDB LLC and/or its subsidiaries.	#
# All rights reserved.						#
#								#
#	This source code contains the intellectual property	#
#	of its copyright holder(s), and is made available	#
#	under a license.  If you do not know the terms of	#
#	the license, please stop and do not read further.	#
#								#
#################################################################

# Usage: gen_error_codes.sh <errfile> [<constfile>] <err_package]]
#
# Generates files <errfile>.{go,h} and <constfile>.{go,h}
# If <constfile> is not specified, puts both sets of constants together into <errfile>.*
#   The .h files are a workaround to prevent errors when compiling the matching .go file
#   (see comments at the start of the .h file for detail).
# if <err_package> is supplied, use it as the package name of <errfile>.go
#   and remove the YDB_ERR_ prefix from the Go constant names.

if [ -z "$ydb_dist" ]; then
    ydb_dist=$(pkg-config --variable=prefix yottadb)
fi

errfile="$1"
constfile="$2"
[ "$constfile" == "" ] && constfile="$errfile"
err_package=$3
[ "$err_package" == "" ] && err_package=yottadb

tmp=/tmp/YDBGo-generate

# Make bash exit early if there are any errors or pipe errors
set -e
set -o pipefail

# Generate complete list of constants across every YDB release (except <r1.20 which doesn't have these files).
# Remove duplicates later.
mkdir -p $tmp
pushd $tmp >/dev/null
if ! [ -d YDB ]; then
    git clone https://gitlab.com/YottaDB/DB/YDB.git/
else
    git  -C YDB  pull
fi

# Awk program to find enums from libyottadb.h
cat <<'EOF' >$tmp/find_enums.awk
    /enum.*\{/ { in_enum=1 }
    /\{/ && prev_line_enum { in_enum=1 }
    (in_enum || /enum[ \t]/) && match($0, "YDB_[0-9a-zA-Z_]+") {
        name=substr($0, RSTART, RLENGTH)
        match($0,"/[*].*[*]/|//.*")
        print ydb_release, name (RSTART>0? " "substr($0, RSTART, RLENGTH): "")
    }
    /\}/ { in_enum=0 }
    { prev_line_enum = (!in_enum && /enum/) }
EOF

# Awk program to generate missing enum #defineds for error_codes.h
cat <<'EOF' >$tmp/gen_enums.awk
    BEGIN { prev=120 }
    !seen[$2]++ {
        ver=$1
        if (ver>prev) { print "#elif YDB_RELEASE < " ver }
        print "  #define " $2, "_YDB_ERROR_UNDEFINED" substr($0, length($1$2)+2)
    }
    { prev=ver }
EOF

# Get list of YDB tags with latest first (so we capture the latest comment, since we capture only the first comment for any constant)
rm *.all r* HEAD -rf  # Remove previous working files
ydb_tags="HEAD `git ls-remote --exit-code --tags --refs YDB 'refs/tags/r*' | grep -o '[^/]*$' | grep -v r1.[01]0 | tac`"
for tag in $ydb_tags; do
    echo -n "Fetching constants from YDB $tag "
    mkdir -p $tmp/$tag
    cd $tmp/$tag
    git -C ../YDB archive $tag "sr_port/libydberrors*.h" "sr_unix/libyottadb.h" | tar -x --strip-components=1
    # Extract constant name from all lines of the form '#define YDB_<name>'
    # Exclude any macros (by detecting the '(' after the macro name)
    # Also append any comments found on the constant definition's line
    cat libyottadb.h libydberrors*.h \
        | grep -E "#define\s+YDB_" | grep -Ev '#define\sYDB_\S*[(]' | grep -Ev '#define\s+YDB_ERR_UNUSED' \
        | awk '{match($0,"/[*].*[*]/"); print $2 (RSTART>0? " "substr($0, RSTART, RLENGTH): "")}' \
        >error_codes.tmp
    # Capture any constants defined using enum
    # In this case, prefix the revision tag so we can define them by revision in error_codes.h
    tagnum=`echo $tag | tr -d r.`  # remove 'r' and '.' characters from tag
    # Now find all 'YDB_*' constants that are defined inside an enum { } clause
    cat libyottadb.h | awk -f $tmp/find_enums.awk -v ydb_release=$tagnum >enum_codes.tmp
    echo "(`cat error_codes.tmp enum_codes.tmp | wc --lines` constants)"
    # Append to master list of codes
    cat error_codes.tmp >>$tmp/error_codes.all
    cat enum_codes.tmp  >>$tmp/enum_codes.all
done
popd >/dev/null

echo "Found `awk '!seen[$1]++' $tmp/error_codes.all | wc -l` unique constants"

# generate non-error constants to $constfile.go file
cat <<EOF > $constfile.go
// Code generated by go generate; DO NOT EDIT.

package yottadb

// #include "$constfile.h"
import "C"

// Define constants exported by YottaDB
EOF

# Output all enum constants first
# Note: the following must be sorted so that in the pipeline, there will be no change in error_codes.go even when the latest .h files have moved some definitions
if [ "$err_package" != "yottadb" ]; then
    echo >>$constfile.go "//"
    echo >>$constfile.go "// Note: YDB_ERR_* error constants are defined in sub-package ydberr."
fi
echo >>$constfile.go "const ("
echo >>$constfile.go -e "\t// YottaDB Enum constants"
cat $tmp/enum_codes.all | sort | awk >>$constfile.go \
    '!seen[$2]++ {print "\t" $2 " = C." $2 substr($0, length($1$2)+2)}'
echo >>$constfile.go ""
echo >>$constfile.go -e "\t// General-purpose constants"
# Output all non- YDB_ERR_* constants
cat $tmp/error_codes.all | sort | awk >>$constfile.go \
    '!seen[$1]++ && !/YDB_ERR_/ {print "\t" $1 " = C." $1 substr($0, length($1)+1)}'
echo >>$constfile.go ")"

# Now output YDB_ERR_* constants
if [ "$errfile" != "$constfile" ]; then
    echo  >$errfile.go "// Code generated by go generate; DO NOT EDIT."
    echo >>$errfile.go ""
    echo >>$errfile.go "package $err_package"
    echo >>$errfile.go ""
    echo >>$errfile.go "// #include \"`basename $errfile.h`\""
    echo >>$errfile.go 'import "C"'
fi
echo >>$errfile.go ""
echo >>$errfile.go "// YottaDB Error constants"
echo >>$errfile.go "const ("
remove_prefix="^YDB_ERR_"
[ "$err_package" == "yottadb" ] && remove_prefix=""
cat $tmp/error_codes.all | sort | awk >>$errfile.go \
    '!seen[$1]++ && /YDB_ERR_/ {name=$1; sub("'"$remove_prefix"'", "", name); print name " = C." $1 substr($0, length($1)+1)}'
echo ")" >> $errfile.go

gofmt -e -w $constfile.go
gofmt -e -w $errfile.go

# generate error constants to .h file #included by error_codes.go above
cat <<EOF > $constfile.h
// Code generated by go generate; DO NOT EDIT.

// Creates C constants for every possible 'YDB_*' constant not defined in the installed version of YottaDB.
// This prevents unnecessary errors when compiling the matching .go constants.
// Constants not defined in the current version of YottaDB are assigned instead to an error message string
// so that the Go compiler creates an error only if the constant is invoked as if it existed (as an integer).

#include "libyottadb.h"

#define _YDB_ERROR_UNDEFINED "error code not defined by your YottaDB installation's libyottadb.h"


EOF
[ "$errfile" != "$constfile" ] && cp "$constfile.h" "$errfile.h"

# Output all enum constants first
# See comment on enums constants in the $constfile.h header above for why the release number is used.
# This time it's sorted by YDB release number since we've prepended that to field 1 of each line.
echo >>$constfile.h "// Enum constants"
echo >>$constfile.h "// (#ifndef does not work on enums, so define them conditionally using the installed YDB release)"
echo >>$constfile.h ""
echo >>$constfile.h "#if !defined(YDB_RELEASE) && !defined(YDB_DEL_TREE)  /* i.e. '#if YDB_RELEASE<120', except YDB_RELEASE was not defined until r1.24 so use this test instead */"

cat $tmp/enum_codes.all | sort | awk -f $tmp/gen_enums.awk >>$constfile.h
echo >>$constfile.h "#endif"
echo >>$constfile.h ""
echo >>$constfile.h ""

# Output all non- YDB_ERR_* constants
cat $tmp/error_codes.all | sort | awk >>$constfile.h \
    '!seen[$1]++ && !/YDB_ERR_/ {print "#ifndef " $1 "\n  #define " $1,"_YDB_ERROR_UNDEFINED\n#endif\n"}'

# Now output YDB_ERR_* constants
cat $tmp/error_codes.all | sort | awk >>$errfile.h \
    '!seen[$1]++ && /YDB_ERR_/ {print "#ifndef " $1 "\n  #define " $1,"_YDB_ERROR_UNDEFINED\n#endif\n"}'

echo "Generated files $errfile.{go,h}" `[ "$errfile" != "$constfile" ] && echo "and $errfile.{go,h}"`
