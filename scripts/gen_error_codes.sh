#!/bin/bash
#################################################################
#								#
# Copyright (c) 2025 YottaDB LLC and/or its subsidiaries.	#
# All rights reserved.						#
#								#
#	This source code contains the intellectual property	#
#	of its copyright holder(s), and is made available	#
#	under a license.  If you do not know the terms of	#
#	the license, please stop and do not read further.	#
#								#
#################################################################

if [ -z "$ydb_dist" ]; then
    ydb_dist=$(pkg-config --variable=prefix yottadb)
fi

# Make bash exit early if there are any errors or pipe errors
set -e
set -o pipefail

outfile=error_codes
tmp=/tmp/YDBGo-generate

# Generate complete list of constants across every YDB release (except <r1.20 which doesn't have these files).
# Remove duplicates later.
mkdir -p $tmp
pushd $tmp >/dev/null
if ! [ -d YDB ]; then
    git clone https://gitlab.com/YottaDB/DB/YDB.git/
else
    git  -C YDB  pull
fi

# Awk program to find enums from libyottadb.h
cat <<'EOF' >$tmp/find_enums.awk
    /enum.*\{/ { in_enum=1 }
    /\{/ && prev_line_enum { in_enum=1 }
    (in_enum || /enum[ \t]/) && match($0, "YDB_[0-9a-zA-Z_]+") {
        name=substr($0, RSTART, RLENGTH)
        match($0,"/[*].*[*]/|//.*")
        print ydb_release, name (RSTART>0? " "substr($0, RSTART, RLENGTH): "")
    }
    /\}/ { in_enum=0 }
    { prev_line_enum = (!in_enum && /enum/) }
EOF

# Awk program to generate missing enum #defineds for error_codes.h
cat <<'EOF' >$tmp/gen_enums.awk
    BEGIN { prev=120 }
    !seen[$2]++ {
        ver=$1
        if (ver>prev) { print "#elif YDB_RELEASE < " ver }
        print "  #define " $2, "_YDB_ERROR_UNDEFINED" substr($0, length($1$2)+2)
    }
    { prev=ver }
EOF

# Get list of YDB tags with latest first (so we capture the latest comment, since we capture only the first comment for any constant)
rm *.all r* HEAD -rf  # Remove previous working files
ydb_tags="HEAD `git ls-remote --exit-code --tags --refs YDB 'refs/tags/r*' | grep -o '[^/]*$' | grep -v r1.[01]0 | tac`"
for tag in $ydb_tags; do
    echo -n "Fetching constants from YDB $tag "
    mkdir -p $tmp/$tag
    cd $tmp/$tag
    git -C ../YDB archive $tag "sr_port/libydberrors*.h" "sr_unix/libyottadb.h" | tar -x --strip-components=1
    # Extract constant name from all lines of the form '#define YDB_<name>'
    # Exclude any macros (by detecting the '(' after the macro name)
    # Also append any comments found on the constant definition's line
    cat libyottadb.h libydberrors*.h \
        | grep -E "#define\s+YDB_" | grep -Ev '#define\sYDB_\S*[(]' | grep -Ev '#define\s+YDB_ERR_UNUSED' \
        | awk '{match($0,"/[*].*[*]/"); print $2 (RSTART>0? " "substr($0, RSTART, RLENGTH): "")}' \
        >error_codes.tmp
    # Capture any constants defined using enum
    # In this case, prefix the revision tag so we can define them by revision in error_codes.h
    tagnum=`echo $tag | tr -d r.`  # remove 'r' and '.' characters from tag
    # Now find all 'YDB_*' constants that are defined inside an enum { } clause
    cat libyottadb.h | awk -f $tmp/find_enums.awk -v ydb_release=$tagnum >enum_codes.tmp
    echo "(`cat error_codes.tmp enum_codes.tmp | wc --lines` constants)"
    # Append to master list of codes
    cat error_codes.tmp >>$tmp/error_codes.all
    cat enum_codes.tmp  >>$tmp/enum_codes.all
done
popd >/dev/null

echo "Found `awk '!seen[$1]++' $tmp/error_codes.all | wc -l` unique constants"

# generate error constants to .go file
cat <<EOF > $outfile.go
// Code generated by go generate; DO NOT EDIT.

package yottadb

// #include "error_codes.h"
import "C"

const (
    // Enum constants
EOF

# Output all enum constants first
# Note: the following must be sorted so that in the pipeline, there will be no change in error_codes.go even when the latest .h files have moved some definitions
cat $tmp/enum_codes.all | sort | awk >>$outfile.go \
    '!seen[$2]++ {print $2 " = C." $2 substr($0, length($1$2)+2)}'
echo >>$outfile.go ""
echo >>$outfile.go "// General-purpose constants"
# Output all non- YDB_ERR_* constants
cat $tmp/error_codes.all | sort | awk >>$outfile.go \
    '!seen[$1]++ && !/YDB_ERR_/ {print $1 " = C." $1 substr($0, length($1)+1)}'
echo >>$outfile.go ""
echo >>$outfile.go "// Error constants"
# Now output YDB_ERR_* constants
cat $tmp/error_codes.all | sort | awk >>$outfile.go \
    '!seen[$1]++ && /YDB_ERR_/ {print $1 " = C." $1 substr($0, length($1)+1)}'

echo ")" >> $outfile.go
gofmt -e -w $outfile.go

# generate error constants to .h file #included by error_codes.go above
cat <<EOF > $outfile.h
// Code generated by go generate; DO NOT EDIT.

// Creates C constants for every possible 'YDB_*' constant not defined in the installed version of YottaDB.
// This prevents unnecessary errors when compiling error_codes.go constants that are not even used elsewhere in the code.
// Constants not defined in the current version of YottaDB are assigned instead to an error message string
// so that the Go compiler creates an error only if the constant is invoked as if it existed (as an integer).

#include "libyottadb.h"

#define _YDB_ERROR_UNDEFINED "error code not defined by your YottaDB installation's libyottadb.h"


// Enum constants
// (#ifndef does not work on enums, so define them conditionally using the installed YDB release)

#if !defined(YDB_RELEASE) && !defined(YDB_DEL_TREE)  /* i.e. '#if YDB_RELEASE<120', except YDB_RELEASE was not defined until r1.24 so use this test instead */
EOF

# Output all enum constants first
# See comment on enums constants in the error_codes.h header above for why the release number is used.
# This time it's sorted by YDB release number since we've prepended that to field 1 of each line.
cat $tmp/enum_codes.all | sort | awk -f $tmp/gen_enums.awk >>$outfile.h
echo "#endif" >>$outfile.h
echo "" >>$outfile.h

# Output all non- YDB_ERR_* constants
cat $tmp/error_codes.all | sort | awk >>$outfile.h \
    '!seen[$1]++ && !/YDB_ERR_/ {print "#ifndef " $1 "\n  #define " $1,"_YDB_ERROR_UNDEFINED\n#endif\n"}'
echo >>$outfile.h ""
echo >>$outfile.h "// Now list all YDB_ERR_* constants"
echo >>$outfile.h ""
# Now output YDB_ERR_* constants
cat $tmp/error_codes.all | sort | awk >>$outfile.h \
    '!seen[$1]++ && /YDB_ERR_/ {print "#ifndef " $1 "\n  #define " $1,"_YDB_ERROR_UNDEFINED\n#endif\n"}'
